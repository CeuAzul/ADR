{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 What is ADR ? \u00b6 ADR is a python library to analyse aircraft conceptual designs. ADR has several tools that allows one to create different aircraft designs and analyse those from different points os view. What can it do? \u00b6 From 2.0, users can specify a free-body with any number of attached (and nested) componentes, in any position. Because of its generalist object-oriented structure, ADR allows components to be attached in any way imaginable, by only specifing to which other component it is attached, its relative position and angle, like so: import math from vec import Vector2 from adr.World import Ambient from adr.Components import FreeBody , AttachedComponent ambient = Ambient () plane = FreeBody ( name = 'plane' , mass = 0.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = ambient ) wing = AttachedComponent ( name = 'wing' , relative_position = Vector2 ( x =- 0.10 , y = 0 ), relative_angle = math . radians ( + 5 ), mass = 0.370 , ) wing . set_parent ( plane ) print ( plane . wing . mass ) >>> 0.37","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#what-is-adr","text":"ADR is a python library to analyse aircraft conceptual designs. ADR has several tools that allows one to create different aircraft designs and analyse those from different points os view.","title":"What is ADR?"},{"location":"#what-can-it-do","text":"From 2.0, users can specify a free-body with any number of attached (and nested) componentes, in any position. Because of its generalist object-oriented structure, ADR allows components to be attached in any way imaginable, by only specifing to which other component it is attached, its relative position and angle, like so: import math from vec import Vector2 from adr.World import Ambient from adr.Components import FreeBody , AttachedComponent ambient = Ambient () plane = FreeBody ( name = 'plane' , mass = 0.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = ambient ) wing = AttachedComponent ( name = 'wing' , relative_position = Vector2 ( x =- 0.10 , y = 0 ), relative_angle = math . radians ( + 5 ), mass = 0.370 , ) wing . set_parent ( plane ) print ( plane . wing . mass ) >>> 0.37","title":"What can it do?"},{"location":"about/","text":"About \u00b6 Why was ADR created? \u00b6 ADR was originally created to allow members of Ceu Azul Aeronaves to iterate through different aircraft conceptual designs in a programmatic manner. With time the team saw that sharing this knowledge by opening the project would stimulate the OpenSource roots to enter the SAE Aerodesign competition.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#why-was-adr-created","text":"ADR was originally created to allow members of Ceu Azul Aeronaves to iterate through different aircraft conceptual designs in a programmatic manner. With time the team saw that sharing this knowledge by opening the project would stimulate the OpenSource roots to enter the SAE Aerodesign competition.","title":"Why was ADR created?"},{"location":"Components/AttachedComponent/","text":"AttachedComponent \u00b6 AttachedComponent is the class where all the other components on ADR inherit from. Together with the FreeBody class it allows one to create a complex network of components that interact to calculate their states. An AttachedComponent will have properties that identify its parent component and its position and angle relative to this parent. By definition an AttachedComponent should always have a parent component, as its states will be calculated using it (eg.: self.angle = self.parent.angle + self.relative_angle ). This parent component can be another AttachedComponent or a FreeBody. On the top of the component's network there should always be a FreeBody, where the main states ( position , angle , velocity and ambient ) will be set. The AttachedComponent class implements three properties and a state, being those parent , relative_position , relative_angle , velocity and actuation_angle . Instantiation \u00b6 To instantiate a AttacheComponent one needs to pass the arguments of its parent class ( name , type and mass ) and also its own ( relative_position and relative_angle ). The parent property is set with the special method set_parent afterwards. The relative_position property should be a 2D vector (using vec.Vector2 class) that represents the position of the component's origin relative to its parent origin (both origins being arbitrary and defined by the user). The relative_angle property should be a float representing the angle of the component relative to its parent, in radians and clockwise. from adr.Components import FreeBody , AttachedComponent from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) wing = AttachedComponent ( name = 'wing' , type = 'wing' , mass = 0.3 , relative_position = Vector2 ( x =- 0.15 , y = 0.2 ), relative_angle = math . radians ( 6 ), ) aileron = AttachedComponent ( name = 'left_aileron' , type = 'aileron' , mass = 0.02 , relative_position = Vector2 ( x =- 0.3 , y = 0 ), relative_angle = math . radians ( 4 ), ) wing . set_parent ( plane ) aileron . set_parent ( wing ) print ( math . degrees ( wing . angle )) >>> 6.0 print ( math . degrees ( aileron . angle )) >>> 10.0 plane . angle = math . radians ( 5 ) print ( math . degrees ( aileron . angle )) >>> 14.99999999999 position property \u00b6 This property returns the absolute position vector of the component wing . set_parent ( plane ) plane . angle = 8 print ( wing . position ) >>> Vector2 ( - 0.17604664425338434 , - 0.17750374375522998 ) ambient property \u00b6 This property returns the environment in which the component is located print ( wing . ambient ) >>> adr . World . Ambient . Ambient object at 0x000001E4F70128E0 velocity property \u00b6 This property returns the speed of the component based on the speed of the parent component wing . set_parent ( plane ) plane . velocity = Vector2 ( 10 , 20 ) print ( wing . velocity ) >>> Vector2 ( 10 , 20 ) reset_state method \u00b6 The reset_state method will reset all the component state variables (actuation_angle), and call BaseComponent's reset_state after, which will reset the state of all child components. plane . angle = math . radians ( 8 ) print ( math . degrees ( plane . angle )) >>> 8.0 plane . reset_state () print ( math . degrees ( plane . angle )) >>> 0.0 ``` ##Angle: The property angle will return to you the angle that the given component is set . Let 's say we have a component ' Wing ' attached to the body of the plane, that is set as a FreeBody Component called ' Plane '. The property angle will take in count the plane angle and the relative angle of the wing, just as shown in the example below: ``` python env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , angle = math . radians ( 3.2 ), position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) wing = AttachedComponent ( name = 'wing' , type = 'wing' , mass = 0.3 , relative_position = Vector2 ( x =- 0.15 , y = 0.2 ), relative_angle = math . radians ( 1 ) ) print ( math . degrees ( wing . angle )) >>> 4.2 If the given component has an actuation angle, the property will return the angle with the maximum actuation angle as well. Let's use another example to demonstrate that: an aileron is attached to the wing, with an actuation angle of 15 degrees and a relative angle of 0 degrees. aileron = AttachedComponent ( name = 'left_aileron' , type = 'aileron' , mass = 0.02 , relative_position = Vector2 ( x =- 0.3 , y = 0 ), relative_angle = math . radians ( 0 ), ) aileron . actuation_angle ( math . radians ( 15 )) aileron . set_parent ( wing ) print ( math . degrees ( aileron . angle )) >>> 19.2 Set_parent \u00b6 The set_parent has already been used in the example above, but to give a further explanation, what the function does is to set a parent to the current component. Note that if we try to set a parent to a component that has already a parent assigned it will return an error. In the example above, the aileron parent is the wing, see what happens if we try to set the plane as the aileron parent: aileron . set_parent ( plane ) >>> raise Exception ( 'Component already has a parent: wing' )","title":"AttachedComponent"},{"location":"Components/AttachedComponent/#attachedcomponent","text":"AttachedComponent is the class where all the other components on ADR inherit from. Together with the FreeBody class it allows one to create a complex network of components that interact to calculate their states. An AttachedComponent will have properties that identify its parent component and its position and angle relative to this parent. By definition an AttachedComponent should always have a parent component, as its states will be calculated using it (eg.: self.angle = self.parent.angle + self.relative_angle ). This parent component can be another AttachedComponent or a FreeBody. On the top of the component's network there should always be a FreeBody, where the main states ( position , angle , velocity and ambient ) will be set. The AttachedComponent class implements three properties and a state, being those parent , relative_position , relative_angle , velocity and actuation_angle .","title":"AttachedComponent"},{"location":"Components/AttachedComponent/#instantiation","text":"To instantiate a AttacheComponent one needs to pass the arguments of its parent class ( name , type and mass ) and also its own ( relative_position and relative_angle ). The parent property is set with the special method set_parent afterwards. The relative_position property should be a 2D vector (using vec.Vector2 class) that represents the position of the component's origin relative to its parent origin (both origins being arbitrary and defined by the user). The relative_angle property should be a float representing the angle of the component relative to its parent, in radians and clockwise. from adr.Components import FreeBody , AttachedComponent from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) wing = AttachedComponent ( name = 'wing' , type = 'wing' , mass = 0.3 , relative_position = Vector2 ( x =- 0.15 , y = 0.2 ), relative_angle = math . radians ( 6 ), ) aileron = AttachedComponent ( name = 'left_aileron' , type = 'aileron' , mass = 0.02 , relative_position = Vector2 ( x =- 0.3 , y = 0 ), relative_angle = math . radians ( 4 ), ) wing . set_parent ( plane ) aileron . set_parent ( wing ) print ( math . degrees ( wing . angle )) >>> 6.0 print ( math . degrees ( aileron . angle )) >>> 10.0 plane . angle = math . radians ( 5 ) print ( math . degrees ( aileron . angle )) >>> 14.99999999999","title":"Instantiation"},{"location":"Components/AttachedComponent/#position-property","text":"This property returns the absolute position vector of the component wing . set_parent ( plane ) plane . angle = 8 print ( wing . position ) >>> Vector2 ( - 0.17604664425338434 , - 0.17750374375522998 )","title":"position property"},{"location":"Components/AttachedComponent/#ambient-property","text":"This property returns the environment in which the component is located print ( wing . ambient ) >>> adr . World . Ambient . Ambient object at 0x000001E4F70128E0","title":"ambient property"},{"location":"Components/AttachedComponent/#velocity-property","text":"This property returns the speed of the component based on the speed of the parent component wing . set_parent ( plane ) plane . velocity = Vector2 ( 10 , 20 ) print ( wing . velocity ) >>> Vector2 ( 10 , 20 )","title":"velocity property"},{"location":"Components/AttachedComponent/#reset_state-method","text":"The reset_state method will reset all the component state variables (actuation_angle), and call BaseComponent's reset_state after, which will reset the state of all child components. plane . angle = math . radians ( 8 ) print ( math . degrees ( plane . angle )) >>> 8.0 plane . reset_state () print ( math . degrees ( plane . angle )) >>> 0.0 ``` ##Angle: The property angle will return to you the angle that the given component is set . Let 's say we have a component ' Wing ' attached to the body of the plane, that is set as a FreeBody Component called ' Plane '. The property angle will take in count the plane angle and the relative angle of the wing, just as shown in the example below: ``` python env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , angle = math . radians ( 3.2 ), position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) wing = AttachedComponent ( name = 'wing' , type = 'wing' , mass = 0.3 , relative_position = Vector2 ( x =- 0.15 , y = 0.2 ), relative_angle = math . radians ( 1 ) ) print ( math . degrees ( wing . angle )) >>> 4.2 If the given component has an actuation angle, the property will return the angle with the maximum actuation angle as well. Let's use another example to demonstrate that: an aileron is attached to the wing, with an actuation angle of 15 degrees and a relative angle of 0 degrees. aileron = AttachedComponent ( name = 'left_aileron' , type = 'aileron' , mass = 0.02 , relative_position = Vector2 ( x =- 0.3 , y = 0 ), relative_angle = math . radians ( 0 ), ) aileron . actuation_angle ( math . radians ( 15 )) aileron . set_parent ( wing ) print ( math . degrees ( aileron . angle )) >>> 19.2","title":"reset_state method"},{"location":"Components/AttachedComponent/#set_parent","text":"The set_parent has already been used in the example above, but to give a further explanation, what the function does is to set a parent to the current component. Note that if we try to set a parent to a component that has already a parent assigned it will return an error. In the example above, the aileron parent is the wing, see what happens if we try to set the plane as the aileron parent: aileron . set_parent ( plane ) >>> raise Exception ( 'Component already has a parent: wing' )","title":"Set_parent"},{"location":"Components/BaseComponent/","text":"Base Component \u00b6 The base component is the fountain where ADR drinks from. Its idea is to provide several properties and methods that are necessary for both AttachedComponent and FreeBody. Usually the final user of ADR won't use BaseComponent directly, using instead the other two. BaseComponent implements the idea of child components (with the children dictionary), methods for dealing with its state and the state of its children, methods for calculating the forces and moments on any component based on the loads in the component itself and its children, among other things. Instantiation \u00b6 One can instantiate a BaseComponent by passing three parameters: name , type and mass . Notice that all parameters should be passed as keyword arguments (eg.: name=\"plane\"). from adr.Components import BaseComponent base_component = BaseComponent ( name = 'component' , type = 'generic_component' , mass = 3.4 ) print ( base_component ) >>> BaseComponent ( name = 'component' , type = 'generic_component' , mass = 3.4 , children = {}, external_forces = {}, external_moments = {}) The other attributes (children, external_forces and external_moments) should not be passed during instantiation, but with specific methods. reset_state method \u00b6 The reset_state method will call the reset_children_state method. It exists so the classes inheriting from BaseComponent can always call it's superclass reset_state method, ultimately calling the reset_children_state method, which will reset all nested components. reset_children_state method \u00b6 The reset_children_state method will call the reset_state method of all the components listed on the children dictionary. append_child method \u00b6 This method is responsible for adding a child to a component child_component = BaseComponent ( \"wing1\" , \"wing\" , 1.1 ) base_component . append_child ( child_component ) print ( base_component . children ) >>> { 'wing1' : BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {})} print ( base_component . wing1 ) >>> BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {}) angle_of_attack property \u00b6 This property calculates the angle of attack of the plane freebody_component = FreeBody ( name = 'component' , type = 'generic_component' , mass = 3.4 , position_cg = Vector2 ( - 0.7 , 0.2 ), pitch_rot_inertia = 30.0 , ambient = Ambient () ) attached_component = AttachedComponent ( name = 'attached_component' , type = 'generic_attached_component' , mass = 1.4 , relative_position = Vector2 ( - 0.4 , 0.1 ), relative_angle = math . radians ( 9 ) ) attached_component . set_parent ( freebody_component ) freebody_component . velocity = Vector2 ( r = 12 , theta = math . radians ( 5 )) print ( math . degrees ( freebody_component . angle_of_attack )) >>> - 5.0 print ( math . degrees ( attached_component . angle_of_attack )) >>> 4.0 empty_mass property \u00b6 This property returns the total mass of the nested components, excluding payload components print ( base_component . empty_mass ) >>> 4.5 nested_components property \u00b6 This property returns a dictionary with the hierarchical relationship of each component print ( base_component . nested_components ) >>> { 'component' : BaseComponent ( name = 'component' , type = 'generic_component' , mass = 3.4 , children = { 'wing1' : BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {})}, external_forces = {}, external_moments = {}), 'wing1' : BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {})} add_external_force_function \u00b6 This method is responsible for appending an external force function to the component. The force function returns a force vector and an application point. def force1 (): mag = 10 ang = math . radians ( 45 ) force_point = Vector2 ( - 10 , 0 ) force1 = Vector2 ( r = mag , theta = ang ) return force1 , force_point base_component . add_external_force_function ( 'force1' , force1 ) print ( base_component . external_forces ) >>> { 'force1' : < function force1 at 0x0000025EBCAA8D30 > } add_external_moment_function : \u00b6 This method is responsible for appending an external moment function to the component. The appended function should return a float representing the magnitude of the moment. def moment1 (): moment1 = 13 return moment1 base_component . add_external_moment_function ( 'moment1' , moment1 ) print ( base_component . external_moments ) >>> { 'moment1' : < function moment1 at 0x7ff87d8891f0 > } moment_from_external_moments method: \u00b6 Returns the resultant pitch moment from the moment functions appended to the component. It does not include child's moments or moments from forces. def moment_from_drag (): return 2 def moment_from_lift (): return 5 freebody_component . add_external_moment_function ( 'drag_moment' , moment_from_drag ) freebody_component . add_external_moment_function ( 'lift_moment' , moment_from_lift ) print ( freebody_component . external_moments ) >>> { 'drag_moment' : < function moment_from_drag at 0x7fe44b2861f0 > , 'lift_moment' : < function moment_from_lift at 0x7fe44af67550 > } print ( freebody_component . moment_from_external_moments ()) >>> 7.0 force_and_moment_from_external_forces method: \u00b6 Similar to moment_from_external_moments, but it returns both the resultant force and the moment of the resultant force on a component (excluding children). def drag_force (): return Vector2 ( - 5 , 0 ), Vector2 ( 3 , 2 ) def lift_force (): return Vector2 ( 0 , 50 ), Vector2 ( 3 , 2 ) freebody_component . external_forces . pop ( 'weight' ) freebody_component . add_external_force_function ( 'drag_force' , drag_force ) freebody_component . add_external_force_function ( 'lift_force' , lift_force ) print ( freebody_component . external_forces ) >>> { 'drag_force' : < function drag_force at 0x7f6fb6e561f0 > , 'lift_force' : < function lift_force at 0x7f6f9f7d3310 > } print ( freebody_component . force_and_moment_from_external_forces ()) >>> ( < Vector2 ( - 4.99999 , 50 ) > , 160.0 ) force_and_moment_from_children method: \u00b6 Returns the resultant force and moment from all the child components at its origin. force_and_moment_at_component_origin method: \u00b6 Returns the resultant force and moment from itself and all the child components, at its origin.","title":"BaseComponent"},{"location":"Components/BaseComponent/#base-component","text":"The base component is the fountain where ADR drinks from. Its idea is to provide several properties and methods that are necessary for both AttachedComponent and FreeBody. Usually the final user of ADR won't use BaseComponent directly, using instead the other two. BaseComponent implements the idea of child components (with the children dictionary), methods for dealing with its state and the state of its children, methods for calculating the forces and moments on any component based on the loads in the component itself and its children, among other things.","title":"Base Component"},{"location":"Components/BaseComponent/#instantiation","text":"One can instantiate a BaseComponent by passing three parameters: name , type and mass . Notice that all parameters should be passed as keyword arguments (eg.: name=\"plane\"). from adr.Components import BaseComponent base_component = BaseComponent ( name = 'component' , type = 'generic_component' , mass = 3.4 ) print ( base_component ) >>> BaseComponent ( name = 'component' , type = 'generic_component' , mass = 3.4 , children = {}, external_forces = {}, external_moments = {}) The other attributes (children, external_forces and external_moments) should not be passed during instantiation, but with specific methods.","title":"Instantiation"},{"location":"Components/BaseComponent/#reset_state-method","text":"The reset_state method will call the reset_children_state method. It exists so the classes inheriting from BaseComponent can always call it's superclass reset_state method, ultimately calling the reset_children_state method, which will reset all nested components.","title":"reset_state method"},{"location":"Components/BaseComponent/#reset_children_state-method","text":"The reset_children_state method will call the reset_state method of all the components listed on the children dictionary.","title":"reset_children_state method"},{"location":"Components/BaseComponent/#append_child-method","text":"This method is responsible for adding a child to a component child_component = BaseComponent ( \"wing1\" , \"wing\" , 1.1 ) base_component . append_child ( child_component ) print ( base_component . children ) >>> { 'wing1' : BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {})} print ( base_component . wing1 ) >>> BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {})","title":"append_child method"},{"location":"Components/BaseComponent/#angle_of_attack-property","text":"This property calculates the angle of attack of the plane freebody_component = FreeBody ( name = 'component' , type = 'generic_component' , mass = 3.4 , position_cg = Vector2 ( - 0.7 , 0.2 ), pitch_rot_inertia = 30.0 , ambient = Ambient () ) attached_component = AttachedComponent ( name = 'attached_component' , type = 'generic_attached_component' , mass = 1.4 , relative_position = Vector2 ( - 0.4 , 0.1 ), relative_angle = math . radians ( 9 ) ) attached_component . set_parent ( freebody_component ) freebody_component . velocity = Vector2 ( r = 12 , theta = math . radians ( 5 )) print ( math . degrees ( freebody_component . angle_of_attack )) >>> - 5.0 print ( math . degrees ( attached_component . angle_of_attack )) >>> 4.0","title":"angle_of_attack property"},{"location":"Components/BaseComponent/#empty_mass-property","text":"This property returns the total mass of the nested components, excluding payload components print ( base_component . empty_mass ) >>> 4.5","title":"empty_mass property"},{"location":"Components/BaseComponent/#nested_components-property","text":"This property returns a dictionary with the hierarchical relationship of each component print ( base_component . nested_components ) >>> { 'component' : BaseComponent ( name = 'component' , type = 'generic_component' , mass = 3.4 , children = { 'wing1' : BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {})}, external_forces = {}, external_moments = {}), 'wing1' : BaseComponent ( name = 'wing1' , type = 'wing' , mass = 1.1 , children = {}, external_forces = {}, external_moments = {})}","title":"nested_components property"},{"location":"Components/BaseComponent/#add_external_force_function","text":"This method is responsible for appending an external force function to the component. The force function returns a force vector and an application point. def force1 (): mag = 10 ang = math . radians ( 45 ) force_point = Vector2 ( - 10 , 0 ) force1 = Vector2 ( r = mag , theta = ang ) return force1 , force_point base_component . add_external_force_function ( 'force1' , force1 ) print ( base_component . external_forces ) >>> { 'force1' : < function force1 at 0x0000025EBCAA8D30 > }","title":"add_external_force_function"},{"location":"Components/BaseComponent/#add_external_moment_function","text":"This method is responsible for appending an external moment function to the component. The appended function should return a float representing the magnitude of the moment. def moment1 (): moment1 = 13 return moment1 base_component . add_external_moment_function ( 'moment1' , moment1 ) print ( base_component . external_moments ) >>> { 'moment1' : < function moment1 at 0x7ff87d8891f0 > }","title":"add_external_moment_function:"},{"location":"Components/BaseComponent/#moment_from_external_moments-method","text":"Returns the resultant pitch moment from the moment functions appended to the component. It does not include child's moments or moments from forces. def moment_from_drag (): return 2 def moment_from_lift (): return 5 freebody_component . add_external_moment_function ( 'drag_moment' , moment_from_drag ) freebody_component . add_external_moment_function ( 'lift_moment' , moment_from_lift ) print ( freebody_component . external_moments ) >>> { 'drag_moment' : < function moment_from_drag at 0x7fe44b2861f0 > , 'lift_moment' : < function moment_from_lift at 0x7fe44af67550 > } print ( freebody_component . moment_from_external_moments ()) >>> 7.0","title":"moment_from_external_moments method:"},{"location":"Components/BaseComponent/#force_and_moment_from_external_forces-method","text":"Similar to moment_from_external_moments, but it returns both the resultant force and the moment of the resultant force on a component (excluding children). def drag_force (): return Vector2 ( - 5 , 0 ), Vector2 ( 3 , 2 ) def lift_force (): return Vector2 ( 0 , 50 ), Vector2 ( 3 , 2 ) freebody_component . external_forces . pop ( 'weight' ) freebody_component . add_external_force_function ( 'drag_force' , drag_force ) freebody_component . add_external_force_function ( 'lift_force' , lift_force ) print ( freebody_component . external_forces ) >>> { 'drag_force' : < function drag_force at 0x7f6fb6e561f0 > , 'lift_force' : < function lift_force at 0x7f6f9f7d3310 > } print ( freebody_component . force_and_moment_from_external_forces ()) >>> ( < Vector2 ( - 4.99999 , 50 ) > , 160.0 )","title":"force_and_moment_from_external_forces method:"},{"location":"Components/BaseComponent/#force_and_moment_from_children-method","text":"Returns the resultant force and moment from all the child components at its origin.","title":"force_and_moment_from_children method:"},{"location":"Components/BaseComponent/#force_and_moment_at_component_origin-method","text":"Returns the resultant force and moment from itself and all the child components, at its origin.","title":"force_and_moment_at_component_origin method:"},{"location":"Components/FreeBody/","text":"Free Body \u00b6 Together with AttachedComponent, the FreeBody class is responsible for creating a network of nested components. Any network of components should have a FreeBody object as its main parent, this is, all the other components should be instances of the AttachedComponent class (or a class that inherits from it) and nested under a FreeBody. This is necessary because when you ask for any state of a AttachedComponent that is dependent of its parent (eg.: angle), it will look at the value of its parent to calculate its own (eg.: self.angle = self.parent.angle + self.relative_angle ). If the parent is also an AttachedComponent, it will also look at its own parent and this will continue until it reaches the top component, that should be able to calculate its own value, not asking any parent. This component is the FreeBody. The FreeBody class implements among other things the position , angle , velocity and rot_velocity states. The user can modify those directly, to represent a specific FreeBody state, or call the move method, which will calculate the forces and moments on the free body and modify the states accordingly. Instantiation \u00b6 To instantiate a FreeBody one needs to pass the arguments of its parent class ( name , type and mass ) and also its own ( position_cg , pitch_rot_inertia and ambient ). The position_cg property should be a 2D vector (using vec.Vector2 class) that represents the gravitational center position of the free body relative to its origin (arbitrary and defined by the user). The pitch_rot_inertia property should be a float representing the rotating inertia of the free body along its pitch axis and will be used to calculate for pitch states ( rot_velocity and angle ). The ambient property should be a instance of the Ambient class and which will be consulted for environment variables (eg.: air density and wind conditions). This ambient instance can be changed during analysis for variating environment conditions. from adr.Components import FreeBody from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) print ( plane . ambient . air_density ) >>> 1.2920513674462337 reset_state method \u00b6 The reset_state method will reset all the component state variables (position, angle, velocity and rot_velocity), and call BaseComponent's reset_state after, which will reset the state of all child components. plane . angle = math . radians ( 8 ) print ( math . degrees ( plane . angle )) >>> 8.0 plane . reset_state () print ( math . degrees ( plane . angle )) >>> 0.0 gravitational_center property \u00b6 This property returns the freebody gravitational center position print ( plane . gravitational_center ) >>> Vector2 ( - 0.05 , 0 ) move method \u00b6 This method moves the FreeBody instance according to free-body physical equations and the instance state, for a given time step. def thrust_force (): return Vector2 ( 10 , 0 ), Vector2 ( 0.4 , - 0.1 ) def lift_force (): return Vector2 ( 0 , 50 ), Vector2 ( 0.1 , 0.2 ) plane . add_external_force_function ( 'thrust' , thrust_force ) plane . add_external_force_function ( 'lift' , lift_force ) plane . mass = 4.0 plane . position = Vector2 ( 10 , 0 ) plane . velocity = Vector2 ( 2.5 , 0 ) plane . angle = math . radians ( 0 ) plane . move ( 1.0 ) print ( plane . position ) >>> < Vector2 ( 15.0000025 , 2.6933500000000006 ) > print ( plane . velocity ) >>> < Vector2 ( 5.000002500000001 , 2.6933500000000006 ) > print ( math . degrees ( plane . angle )) >>> 16.233804195373324 plane . move ( 1.0 ) print ( plane . position ) >>> < Vector2 ( 19.758483712364665 , 8.471051772483769 ) > print ( plane . velocity ) >>> < Vector2 ( 4.7584812123646625 , 5.777701772483768 ) > print ( math . degrees ( plane . angle )) >>> 48.70141258611997 Notice that the quality of the output depends on the quality of the input. If the force and moment functions are not representative, the moving method won't deliver good results. force_and_moment_at_cg method: \u00b6 Returns the resultant force and moment from itself and all the child components at its gravitational center.","title":"FreeBody"},{"location":"Components/FreeBody/#free-body","text":"Together with AttachedComponent, the FreeBody class is responsible for creating a network of nested components. Any network of components should have a FreeBody object as its main parent, this is, all the other components should be instances of the AttachedComponent class (or a class that inherits from it) and nested under a FreeBody. This is necessary because when you ask for any state of a AttachedComponent that is dependent of its parent (eg.: angle), it will look at the value of its parent to calculate its own (eg.: self.angle = self.parent.angle + self.relative_angle ). If the parent is also an AttachedComponent, it will also look at its own parent and this will continue until it reaches the top component, that should be able to calculate its own value, not asking any parent. This component is the FreeBody. The FreeBody class implements among other things the position , angle , velocity and rot_velocity states. The user can modify those directly, to represent a specific FreeBody state, or call the move method, which will calculate the forces and moments on the free body and modify the states accordingly.","title":"Free Body"},{"location":"Components/FreeBody/#instantiation","text":"To instantiate a FreeBody one needs to pass the arguments of its parent class ( name , type and mass ) and also its own ( position_cg , pitch_rot_inertia and ambient ). The position_cg property should be a 2D vector (using vec.Vector2 class) that represents the gravitational center position of the free body relative to its origin (arbitrary and defined by the user). The pitch_rot_inertia property should be a float representing the rotating inertia of the free body along its pitch axis and will be used to calculate for pitch states ( rot_velocity and angle ). The ambient property should be a instance of the Ambient class and which will be consulted for environment variables (eg.: air density and wind conditions). This ambient instance can be changed during analysis for variating environment conditions. from adr.Components import FreeBody from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) print ( plane . ambient . air_density ) >>> 1.2920513674462337","title":"Instantiation"},{"location":"Components/FreeBody/#reset_state-method","text":"The reset_state method will reset all the component state variables (position, angle, velocity and rot_velocity), and call BaseComponent's reset_state after, which will reset the state of all child components. plane . angle = math . radians ( 8 ) print ( math . degrees ( plane . angle )) >>> 8.0 plane . reset_state () print ( math . degrees ( plane . angle )) >>> 0.0","title":"reset_state method"},{"location":"Components/FreeBody/#gravitational_center-property","text":"This property returns the freebody gravitational center position print ( plane . gravitational_center ) >>> Vector2 ( - 0.05 , 0 )","title":"gravitational_center property"},{"location":"Components/FreeBody/#move-method","text":"This method moves the FreeBody instance according to free-body physical equations and the instance state, for a given time step. def thrust_force (): return Vector2 ( 10 , 0 ), Vector2 ( 0.4 , - 0.1 ) def lift_force (): return Vector2 ( 0 , 50 ), Vector2 ( 0.1 , 0.2 ) plane . add_external_force_function ( 'thrust' , thrust_force ) plane . add_external_force_function ( 'lift' , lift_force ) plane . mass = 4.0 plane . position = Vector2 ( 10 , 0 ) plane . velocity = Vector2 ( 2.5 , 0 ) plane . angle = math . radians ( 0 ) plane . move ( 1.0 ) print ( plane . position ) >>> < Vector2 ( 15.0000025 , 2.6933500000000006 ) > print ( plane . velocity ) >>> < Vector2 ( 5.000002500000001 , 2.6933500000000006 ) > print ( math . degrees ( plane . angle )) >>> 16.233804195373324 plane . move ( 1.0 ) print ( plane . position ) >>> < Vector2 ( 19.758483712364665 , 8.471051772483769 ) > print ( plane . velocity ) >>> < Vector2 ( 4.7584812123646625 , 5.777701772483768 ) > print ( math . degrees ( plane . angle )) >>> 48.70141258611997 Notice that the quality of the output depends on the quality of the input. If the force and moment functions are not representative, the moving method won't deliver good results.","title":"move method"},{"location":"Components/FreeBody/#force_and_moment_at_cg-method","text":"Returns the resultant force and moment from itself and all the child components at its gravitational center.","title":"force_and_moment_at_cg method:"},{"location":"Components/Auxiliary/LandingGear/","text":"LandingGear \u00b6 LandingGear is a component created to be used for ground simulation situations. It simulates a dumped oscillator, this is, a dumped string-mass system. Imagine you want to perform a simulation of a plane takeoff or landing. You need a component that interacts with the ground, generating reaction forces oposing the total weight of the body (normal reaction) and its velocity (friction force). LandingGear does that. Instantiation \u00b6 To instantiate a LandingGear one can pass the same arguments used to instantiate an AttachedComponent, plus the following: - height: used to calculate for the displacement of the spring - spring_coeff: used to calculate the spring reaction - dump_coeff: used to calculate the dumpener friction - friction_coeff: used to calculate the friction of the wheels to the ground import math from vec import Vector2 from adr.Components.Auxiliary import LandingGear main_landing_gear = LandingGear ( name = 'main_landing_gear' , relative_position = Vector2 ( x =- 0.2 , y = 0 ), relative_angle = math . radians ( 0 ), mass = 0.3 , height = 0.1 , spring_coeff = 1000 , dump_coeff = 50 , friction_coeff = 0.05 ) print ( main_landing_gear . type ) >>> landing_gear To simulate the behaviour of the landing gear, one needs to attach it to a FreeBody instance. Let's to that: from adr.World import Ambient from adr.Components import FreeBody env = Ambient () plane = FreeBody ( name = 'plane' , type = 'plane' , mass = 23.4 , position_cg = Vector2 ( - 0.2 , 0.02 ), pitch_rot_inertia = 5.2 , ambient = env , ) main_landing_gear . set_parent ( plane ) And finally let's impose some state to the plane so the landing gear reactions can be calculated: plane . velocity = Vector2 ( 6 , 0.4 ) plane . position = Vector2 ( 10 , 0 ) reaction , contact_point = main_landing_gear . gear_reaction () print ( reaction ) print ( contact_point ) >>> < Vector2 ( 0 , 80.0 ) > >>> < Vector2 ( 0 , - 0.1 ) > friction , contact_point = main_landing_gear . gear_friction () print ( friction ) print ( contact_point ) >>> < Vector2 ( - 4.0 , 0 ) > >>> < Vector2 ( 0 , - 0.1 ) > So one can see that when the airplane is at 0 m to the ground (maximum spring displacement) and with a 10 m/s velocity on the forward direction, there's a 80 N normal force oposing the weight and a 4 N friction force oposing the movement.","title":"LandingGear"},{"location":"Components/Auxiliary/LandingGear/#landinggear","text":"LandingGear is a component created to be used for ground simulation situations. It simulates a dumped oscillator, this is, a dumped string-mass system. Imagine you want to perform a simulation of a plane takeoff or landing. You need a component that interacts with the ground, generating reaction forces oposing the total weight of the body (normal reaction) and its velocity (friction force). LandingGear does that.","title":"LandingGear"},{"location":"Components/Auxiliary/LandingGear/#instantiation","text":"To instantiate a LandingGear one can pass the same arguments used to instantiate an AttachedComponent, plus the following: - height: used to calculate for the displacement of the spring - spring_coeff: used to calculate the spring reaction - dump_coeff: used to calculate the dumpener friction - friction_coeff: used to calculate the friction of the wheels to the ground import math from vec import Vector2 from adr.Components.Auxiliary import LandingGear main_landing_gear = LandingGear ( name = 'main_landing_gear' , relative_position = Vector2 ( x =- 0.2 , y = 0 ), relative_angle = math . radians ( 0 ), mass = 0.3 , height = 0.1 , spring_coeff = 1000 , dump_coeff = 50 , friction_coeff = 0.05 ) print ( main_landing_gear . type ) >>> landing_gear To simulate the behaviour of the landing gear, one needs to attach it to a FreeBody instance. Let's to that: from adr.World import Ambient from adr.Components import FreeBody env = Ambient () plane = FreeBody ( name = 'plane' , type = 'plane' , mass = 23.4 , position_cg = Vector2 ( - 0.2 , 0.02 ), pitch_rot_inertia = 5.2 , ambient = env , ) main_landing_gear . set_parent ( plane ) And finally let's impose some state to the plane so the landing gear reactions can be calculated: plane . velocity = Vector2 ( 6 , 0.4 ) plane . position = Vector2 ( 10 , 0 ) reaction , contact_point = main_landing_gear . gear_reaction () print ( reaction ) print ( contact_point ) >>> < Vector2 ( 0 , 80.0 ) > >>> < Vector2 ( 0 , - 0.1 ) > friction , contact_point = main_landing_gear . gear_friction () print ( friction ) print ( contact_point ) >>> < Vector2 ( - 4.0 , 0 ) > >>> < Vector2 ( 0 , - 0.1 ) > So one can see that when the airplane is at 0 m to the ground (maximum spring displacement) and with a 10 m/s velocity on the forward direction, there's a 80 N normal force oposing the weight and a 4 N friction force oposing the movement.","title":"Instantiation"},{"location":"World/Ambient/","text":"Ambient \u00b6 This class will give you the ambient parameters, such as Temperature, Pressure and humidity, it will also return to you the Air Density property. By default the instantiation values will be: Temperature = 273.15, Pressure = 101325 and Humidity = 0 You can change these values in the instatiation of the class. Air density property \u00b6 This property returns the air density for the given ambient. from adr.World import Ambient ambient = Ambient ( temperature = 300 , pressure = 101325 , humidity = 10 ) print ( ambient . air_density ) >>> 1.1764 Note that if you enter unvalid ambient instantiaon values, it will return an error. from adr.World import Ambient ambient = Ambient ( temperature = 300 , pressure = 101325 , humidity = - 30 ) print ( ambient . air_density ) >>> raise ValueError ( f \"Absolute temperature and absolute pressure should be greater than zero. \\ Humidity should be between 0 and 100. \\ Found temp = 300, pressure = 101325 and humidity = -30\" )","title":"Ambient"},{"location":"World/Ambient/#ambient","text":"This class will give you the ambient parameters, such as Temperature, Pressure and humidity, it will also return to you the Air Density property. By default the instantiation values will be: Temperature = 273.15, Pressure = 101325 and Humidity = 0 You can change these values in the instatiation of the class.","title":"Ambient"},{"location":"World/Ambient/#air-density-property","text":"This property returns the air density for the given ambient. from adr.World import Ambient ambient = Ambient ( temperature = 300 , pressure = 101325 , humidity = 10 ) print ( ambient . air_density ) >>> 1.1764 Note that if you enter unvalid ambient instantiaon values, it will return an error. from adr.World import Ambient ambient = Ambient ( temperature = 300 , pressure = 101325 , humidity = - 30 ) print ( ambient . air_density ) >>> raise ValueError ( f \"Absolute temperature and absolute pressure should be greater than zero. \\ Humidity should be between 0 and 100. \\ Found temp = 300, pressure = 101325 and humidity = -30\" )","title":"Air density property"},{"location":"World/constants/","text":"Constants \u00b6 This file contains several constants available: Constant Value gravitacional acceleration 9.80665 air molar mass 0.02896 air gas constant 287.1016","title":"constants"},{"location":"World/constants/#constants","text":"This file contains several constants available: Constant Value gravitacional acceleration 9.80665 air molar mass 0.02896 air gas constant 287.1016","title":"Constants"},{"location":"helper%20functions/algebric/","text":"Algebric helper functions \u00b6 Some algebric helper functions are available so one can easily deal with transformations of the vectors in 2D space. rotate(vector2d, angle_radians) : \u00b6 Given a vec.Vector2 and an angle (in radians), returns a new vec.Vector2 instance equal to the original vector rotated by the angle. from adr.helper_functions import rotate from vec import Vector2 import math v1 = Vector2 ( 0.7 , 0.2 ) v1_rot_90 = rotate ( v1 , math . radians ( 90 )) print ( v1_rot_90 ) >>> < Vector2 ( - 0.19999999999999996 , 0.7 ) > Notice the vec library doesn't always provide rounded coordinates because of float point precision. translate(vector2d, displacement_x, displacement_y) : \u00b6 Given a vec.Vector2 and displacements on x and y coordinates, returns a new vec.Vector2 instance equal to the original vector translated by the displacements. from adr.helper_functions import translate from vec import Vector2 import math v1 = Vector2 ( 0.5 , - 0.1 ) v1_trans = translate ( v1 , 0.5 , 0.1 ) print ( v1_trans_90 ) >>> < Vector2 ( 1.0 , 0.0 ) > transform(vector2d, angle_radians, displacement_x, displacement_y) : \u00b6 Given a vec.Vector2, an angle (in radians) and displacements on x and y coordinates, returns a new vec.Vector2 instance equal to the original vector rotated and translated by the given inputs. from adr.helper_functions import transform from vec import Vector2 import math v1 = Vector2 ( 0.5 , - 0.1 ) v1_new = transform ( v1 , math . radians ( 45 ) 0.5 , 0.1 ) print ( v1_new ) >>> < Vector2 ( 1.0 , 0.0 ) > Notice the rotating operation hapens before the translation, and they not commute. component_vector_in_absolute_frame(vector, component) : \u00b6 This function is an abstraction of the transform function for components. One can use it to get the absolute coordinates of a vector in the component reference frame. I from adr.helper_functions import component_vector_in_absolute_frame from adr.Components import FreeBody from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) plane . position = Vector2 ( 20 , 5 ) plane . angle = math . radians ( 20 ) v1_in_plane = Vector2 ( 2.0 , 0 ) v1_in_absolute = component_vector_in_absolute_frame ( v1_in_plane , plane ) print ( v1_in_absolute ) >>> < Vector2 ( 21.879385241571818 , 5.684040286651338 ) > component_vector_coords_in_absolute_frame(vector_origin, vector, component) : \u00b6 This function is similar to component_vector_in_absolute_frame, but it's goal is to return vectors in the component frame that have it's origin different from the component's origin. from adr.helper_functions import component_vector_coords_in_absolute_frame from adr.Components import FreeBody from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) plane . position = Vector2 ( 20 , 5 ) plane . angle = math . radians ( 0 ) v1_origin_in_plane = Vector2 ( 0 , 1.0 ) v1 = Vector2 ( 3 , 0 ) x0 , y0 , x , y = component_vector_coords_in_absolute_frame ( v1_origin_in_plane , v1 , plane ) print ( x0 , y0 , x , y ) >>> 20.0 6.0 23.0 6.0","title":"algebric"},{"location":"helper%20functions/algebric/#algebric-helper-functions","text":"Some algebric helper functions are available so one can easily deal with transformations of the vectors in 2D space.","title":"Algebric helper functions"},{"location":"helper%20functions/algebric/#rotatevector2d-angle_radians","text":"Given a vec.Vector2 and an angle (in radians), returns a new vec.Vector2 instance equal to the original vector rotated by the angle. from adr.helper_functions import rotate from vec import Vector2 import math v1 = Vector2 ( 0.7 , 0.2 ) v1_rot_90 = rotate ( v1 , math . radians ( 90 )) print ( v1_rot_90 ) >>> < Vector2 ( - 0.19999999999999996 , 0.7 ) > Notice the vec library doesn't always provide rounded coordinates because of float point precision.","title":"rotate(vector2d, angle_radians):"},{"location":"helper%20functions/algebric/#translatevector2d-displacement_x-displacement_y","text":"Given a vec.Vector2 and displacements on x and y coordinates, returns a new vec.Vector2 instance equal to the original vector translated by the displacements. from adr.helper_functions import translate from vec import Vector2 import math v1 = Vector2 ( 0.5 , - 0.1 ) v1_trans = translate ( v1 , 0.5 , 0.1 ) print ( v1_trans_90 ) >>> < Vector2 ( 1.0 , 0.0 ) >","title":"translate(vector2d, displacement_x, displacement_y):"},{"location":"helper%20functions/algebric/#transformvector2d-angle_radians-displacement_x-displacement_y","text":"Given a vec.Vector2, an angle (in radians) and displacements on x and y coordinates, returns a new vec.Vector2 instance equal to the original vector rotated and translated by the given inputs. from adr.helper_functions import transform from vec import Vector2 import math v1 = Vector2 ( 0.5 , - 0.1 ) v1_new = transform ( v1 , math . radians ( 45 ) 0.5 , 0.1 ) print ( v1_new ) >>> < Vector2 ( 1.0 , 0.0 ) > Notice the rotating operation hapens before the translation, and they not commute.","title":"transform(vector2d, angle_radians, displacement_x, displacement_y):"},{"location":"helper%20functions/algebric/#component_vector_in_absolute_framevector-component","text":"This function is an abstraction of the transform function for components. One can use it to get the absolute coordinates of a vector in the component reference frame. I from adr.helper_functions import component_vector_in_absolute_frame from adr.Components import FreeBody from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) plane . position = Vector2 ( 20 , 5 ) plane . angle = math . radians ( 20 ) v1_in_plane = Vector2 ( 2.0 , 0 ) v1_in_absolute = component_vector_in_absolute_frame ( v1_in_plane , plane ) print ( v1_in_absolute ) >>> < Vector2 ( 21.879385241571818 , 5.684040286651338 ) >","title":"component_vector_in_absolute_frame(vector, component):"},{"location":"helper%20functions/algebric/#component_vector_coords_in_absolute_framevector_origin-vector-component","text":"This function is similar to component_vector_in_absolute_frame, but it's goal is to return vectors in the component frame that have it's origin different from the component's origin. from adr.helper_functions import component_vector_coords_in_absolute_frame from adr.Components import FreeBody from adr.World import Ambient from vec import Vector2 import math env = Ambient () plane = FreeBody ( name = 'plane' , type = 'vehicle' , mass = 2.0 , position_cg = Vector2 ( x =- 0.05 , y = 0 ), pitch_rot_inertia = 30.0 , ambient = env ) plane . position = Vector2 ( 20 , 5 ) plane . angle = math . radians ( 0 ) v1_origin_in_plane = Vector2 ( 0 , 1.0 ) v1 = Vector2 ( 3 , 0 ) x0 , y0 , x , y = component_vector_coords_in_absolute_frame ( v1_origin_in_plane , v1 , plane ) print ( x0 , y0 , x , y ) >>> 20.0 6.0 23.0 6.0","title":"component_vector_coords_in_absolute_frame(vector_origin, vector, component):"}]}